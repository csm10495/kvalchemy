<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>kvalchemy.client API documentation</title>
<meta name="description" content="Home to the KVAlchemy client." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kvalchemy.client</code></h1>
</header>
<section id="section-intro">
<p>Home to the KVAlchemy client.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Home to the KVAlchemy client.
&#34;&#34;&#34;
import contextlib
import logging
from typing import Any, Callable, Iterable, Union

from sqlalchemy import create_engine
from sqlalchemy.orm import Session, scoped_session, sessionmaker

from kvalchemy.models import KEY_MAX_LENGTH, TAG_MAX_LENGTH, Base, KVStore, ValueMixIn
from kvalchemy.proxy import Proxy
from kvalchemy.time import ExpirationType, to_expire
from kvalchemy.values import ENOVAL

log = logging.getLogger(__name__)

MEMOIZE_TAG = &#34;__memoize__&#34;


class KVAlchemy:
    &#34;&#34;&#34;
    Client for working with the key-value store.
    &#34;&#34;&#34;

    def __init__(self, url: str, create_models: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Initializes the KVAlchemy client.

        Takes in the sqlalchemy url to connect to the database, along
        with an option to ensure the necessary db models are created.
        &#34;&#34;&#34;
        self.url = url
        self._engine = create_engine(url)

        if create_models:
            Base.metadata.create_all(self._engine)

        self._session_factory = sessionmaker(bind=self._engine)
        self._session = scoped_session(self._session_factory)

    def __iter__(self) -&gt; Iterable[str]:
        &#34;&#34;&#34;
        Returns an iterable of all non-expired keys in the store.
        &#34;&#34;&#34;
        with self.session(commit=False) as session:
            query = (
                session.query(KVStore)
                .filter(KVStore.non_expired_filter())
                .order_by(KVStore.key.asc(), KVStore.tag.asc())
            )
            for key in query.all():
                yield key

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of non-expired key-value pairs in the store.
        &#34;&#34;&#34;
        count = 0
        for _ in self:
            count += 1
        return count

    @contextlib.contextmanager
    def session(
        self, commit: bool = True, delete_expired: bool = True
    ) -&gt; Iterable[Session]:
        &#34;&#34;&#34;
        Contextmanager to obtain a temp session with the underlying database.

        If commit is True, the session will be committed after the block.
        If delete_expired is True, any expired keys will be deleted before exiting the block.
            Note that delete_expired only applies if commit is True.
        &#34;&#34;&#34;
        with self._session() as session:
            yield session

            if commit:
                if delete_expired:
                    session.query(KVStore).filter(
                        ~KVStore.non_expired_filter()
                    ).delete()

                session.commit()

    def get(
        self,
        key: str,
        default: Any = ENOVAL,
        tag: str = &#34;&#34;,
        return_expiration: bool = False,
    ) -&gt; Any:
        &#34;&#34;&#34;
        Retrieves the value for the given key and tag.

        If the key/tag combo is not found (or expired), and a default is provided, the
        default value is returned. If no default is provided, a KeyError is raised.

        If return_expiration is True, will return the (value, (expiration datetime or None)) as a tuple
        &#34;&#34;&#34;
        with self.session() as session:
            query = (
                session.query(KVStore)
                .filter(KVStore.non_expired_filter())
                .filter_by(key=key, tag=tag)
            )
            result = query.one_or_none()

            if result is None:
                result = ValueMixIn(default)

            if result.value is ENOVAL:
                raise KeyError(f&#34;key: {key}, tag: {tag}&#34;)

            if return_expiration:
                return result.value, getattr(result, &#34;expire&#34;, None)

            return result.value

    def set(
        self, key: str, value: Any, tag: str = &#34;&#34;, expire: ExpirationType = None
    ) -&gt; None:
        &#34;&#34;&#34;
        Sets the given key/tag combo to the value provided.

        If expire is provided, it must be something that can be processed by
        the to_expire function in kvalchemy.time.
        &#34;&#34;&#34;
        with self.session() as session:
            session.merge(
                KVStore(key=key, value=value, tag=tag, expire=to_expire(expire))
            )

    def delete(self, key: str, tag: str = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;
        Deletes the given key/tag combo from the store.
        &#34;&#34;&#34;
        with self.session() as session:
            query = (
                session.query(KVStore)
                .filter(KVStore.non_expired_filter())
                .filter_by(key=key, tag=tag)
            )
            result = query.one_or_none()

            if result is not None:
                session.delete(result)

    def pop(self, key: str, default: Any = ENOVAL, tag: str = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;
        Pops the given key/tag combo from the store.

        If the key/tag combo is not found (or expired), and a default is provided, the
        default value is returned. If no default is provided, a KeyError is raised.
        &#34;&#34;&#34;
        sentinel = object()
        value = self.get(key, sentinel, tag)

        if value is sentinel:
            if default is ENOVAL:
                raise KeyError(f&#34;key: {key}, tag: {tag}&#34;)
            else:
                value = default

        self.delete(key, tag)

        return value

    def clear(self) -&gt; None:
        &#34;&#34;&#34;
        Clears all key-value pairs from the store.
        &#34;&#34;&#34;
        with self.session() as session:
            session.query(KVStore).delete()

    def get_proxy(self, key: str, default: Any = ENOVAL, tag: str = &#34;&#34;) -&gt; Proxy:
        &#34;&#34;&#34;
        Returns a Proxy object for the given key, tag, default.
        &#34;&#34;&#34;
        return Proxy(self, key, default, tag)

    def delete_tag(self, tag: str) -&gt; int:
        &#34;&#34;&#34;
        Deletes all keys under a given tag.

        Returns the number of keys deleted.
        &#34;&#34;&#34;
        with self.session() as session:
            return session.query(KVStore).filter(KVStore.tag == tag).delete()

    def memoize(
        self,
        expire: ExpirationType = None,
        expire_if: Union[bool, Callable] = False,
        skip_saving_to_cache_if: Union[bool, Callable] = False,
    ):
        &#34;&#34;&#34;
        A decorator to memoize the results of a function into the key-value store.

        expire allows us to specify a ttl to expire this memoization on.

        expire_if allows a bool or callable, if callable it will be called (and should return a bool).
            If it is True, we&#39;ll expire the cache and allow the func to be called.
            If it is False, the cache will be hit per the existing ttl.

        skip_saving_to_cache_if allows a bool or callable, if callable it will be called with a single param of the value about to be returned
            (and should return a bool). This is only checked if the underlying function is otherwised called.
            If it is True, we will not save this value as memoized (so next call with hit the function again).
            If it is False, we will save the value to the cache as per normal.
        &#34;&#34;&#34;
        if callable(expire):
            # we&#39;ve been called like:
            # @memoize
            # without () at the end
            func = expire
            expire = None
        else:
            func = None

        def inner(func):
            # Warning: we&#39;re truncating to fit the tag
            tag = f&#34;memoize.{func.__module__}_{func.__qualname__}_{expire!s}&#34;[
                :TAG_MAX_LENGTH
            ]

            def wrapper(*args, **kwargs):
                # Warning: we&#39;re truncating to fit the key
                key = f&#34;{args!s}_{kwargs!s}&#34;[:KEY_MAX_LENGTH]

                # if you overwrite inner.expire_if then the callable would only get evaluated once
                # ... so don&#39;t do that.
                expire_if = inner.expire_if

                if callable(expire_if):
                    expire_if = expire_if()

                try_cache = not bool(expire_if)

                NO_RESULT = object()
                result = NO_RESULT
                if try_cache:
                    try:
                        result = self.get(key, tag=tag)
                    except KeyError:
                        pass
                else:
                    log.debug(f&#34;expire_if is forcing us to ignore cache: {key}&#34;)

                if result == NO_RESULT:
                    result = func(*args, **kwargs)

                    skip_saving_to_cache = False
                    if callable(skip_saving_to_cache_if):
                        if skip_saving_to_cache_if(result):
                            skip_saving_to_cache = True
                    elif skip_saving_to_cache_if:
                        skip_saving_to_cache = skip_saving_to_cache_if

                    if skip_saving_to_cache:
                        log.debug(
                            f&#34;skip_saving_to_cache_if is forcing us to not save to cache the value for key: {key}&#34;
                        )
                    else:
                        self.set(key, result, tag=tag, expire=expire)

                return result

            wrapper.cache_clear = lambda: self.delete_tag(tag)
            return wrapper

        inner.expire_if = expire_if

        if func:
            return inner(func)
        else:
            return inner</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="kvalchemy.client.KVAlchemy"><code class="flex name class">
<span>class <span class="ident">KVAlchemy</span></span>
<span>(</span><span>url: str, create_models: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Client for working with the key-value store.</p>
<p>Initializes the KVAlchemy client.</p>
<p>Takes in the sqlalchemy url to connect to the database, along
with an option to ensure the necessary db models are created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KVAlchemy:
    &#34;&#34;&#34;
    Client for working with the key-value store.
    &#34;&#34;&#34;

    def __init__(self, url: str, create_models: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Initializes the KVAlchemy client.

        Takes in the sqlalchemy url to connect to the database, along
        with an option to ensure the necessary db models are created.
        &#34;&#34;&#34;
        self.url = url
        self._engine = create_engine(url)

        if create_models:
            Base.metadata.create_all(self._engine)

        self._session_factory = sessionmaker(bind=self._engine)
        self._session = scoped_session(self._session_factory)

    def __iter__(self) -&gt; Iterable[str]:
        &#34;&#34;&#34;
        Returns an iterable of all non-expired keys in the store.
        &#34;&#34;&#34;
        with self.session(commit=False) as session:
            query = (
                session.query(KVStore)
                .filter(KVStore.non_expired_filter())
                .order_by(KVStore.key.asc(), KVStore.tag.asc())
            )
            for key in query.all():
                yield key

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of non-expired key-value pairs in the store.
        &#34;&#34;&#34;
        count = 0
        for _ in self:
            count += 1
        return count

    @contextlib.contextmanager
    def session(
        self, commit: bool = True, delete_expired: bool = True
    ) -&gt; Iterable[Session]:
        &#34;&#34;&#34;
        Contextmanager to obtain a temp session with the underlying database.

        If commit is True, the session will be committed after the block.
        If delete_expired is True, any expired keys will be deleted before exiting the block.
            Note that delete_expired only applies if commit is True.
        &#34;&#34;&#34;
        with self._session() as session:
            yield session

            if commit:
                if delete_expired:
                    session.query(KVStore).filter(
                        ~KVStore.non_expired_filter()
                    ).delete()

                session.commit()

    def get(
        self,
        key: str,
        default: Any = ENOVAL,
        tag: str = &#34;&#34;,
        return_expiration: bool = False,
    ) -&gt; Any:
        &#34;&#34;&#34;
        Retrieves the value for the given key and tag.

        If the key/tag combo is not found (or expired), and a default is provided, the
        default value is returned. If no default is provided, a KeyError is raised.

        If return_expiration is True, will return the (value, (expiration datetime or None)) as a tuple
        &#34;&#34;&#34;
        with self.session() as session:
            query = (
                session.query(KVStore)
                .filter(KVStore.non_expired_filter())
                .filter_by(key=key, tag=tag)
            )
            result = query.one_or_none()

            if result is None:
                result = ValueMixIn(default)

            if result.value is ENOVAL:
                raise KeyError(f&#34;key: {key}, tag: {tag}&#34;)

            if return_expiration:
                return result.value, getattr(result, &#34;expire&#34;, None)

            return result.value

    def set(
        self, key: str, value: Any, tag: str = &#34;&#34;, expire: ExpirationType = None
    ) -&gt; None:
        &#34;&#34;&#34;
        Sets the given key/tag combo to the value provided.

        If expire is provided, it must be something that can be processed by
        the to_expire function in kvalchemy.time.
        &#34;&#34;&#34;
        with self.session() as session:
            session.merge(
                KVStore(key=key, value=value, tag=tag, expire=to_expire(expire))
            )

    def delete(self, key: str, tag: str = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;
        Deletes the given key/tag combo from the store.
        &#34;&#34;&#34;
        with self.session() as session:
            query = (
                session.query(KVStore)
                .filter(KVStore.non_expired_filter())
                .filter_by(key=key, tag=tag)
            )
            result = query.one_or_none()

            if result is not None:
                session.delete(result)

    def pop(self, key: str, default: Any = ENOVAL, tag: str = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;
        Pops the given key/tag combo from the store.

        If the key/tag combo is not found (or expired), and a default is provided, the
        default value is returned. If no default is provided, a KeyError is raised.
        &#34;&#34;&#34;
        sentinel = object()
        value = self.get(key, sentinel, tag)

        if value is sentinel:
            if default is ENOVAL:
                raise KeyError(f&#34;key: {key}, tag: {tag}&#34;)
            else:
                value = default

        self.delete(key, tag)

        return value

    def clear(self) -&gt; None:
        &#34;&#34;&#34;
        Clears all key-value pairs from the store.
        &#34;&#34;&#34;
        with self.session() as session:
            session.query(KVStore).delete()

    def get_proxy(self, key: str, default: Any = ENOVAL, tag: str = &#34;&#34;) -&gt; Proxy:
        &#34;&#34;&#34;
        Returns a Proxy object for the given key, tag, default.
        &#34;&#34;&#34;
        return Proxy(self, key, default, tag)

    def delete_tag(self, tag: str) -&gt; int:
        &#34;&#34;&#34;
        Deletes all keys under a given tag.

        Returns the number of keys deleted.
        &#34;&#34;&#34;
        with self.session() as session:
            return session.query(KVStore).filter(KVStore.tag == tag).delete()

    def memoize(
        self,
        expire: ExpirationType = None,
        expire_if: Union[bool, Callable] = False,
        skip_saving_to_cache_if: Union[bool, Callable] = False,
    ):
        &#34;&#34;&#34;
        A decorator to memoize the results of a function into the key-value store.

        expire allows us to specify a ttl to expire this memoization on.

        expire_if allows a bool or callable, if callable it will be called (and should return a bool).
            If it is True, we&#39;ll expire the cache and allow the func to be called.
            If it is False, the cache will be hit per the existing ttl.

        skip_saving_to_cache_if allows a bool or callable, if callable it will be called with a single param of the value about to be returned
            (and should return a bool). This is only checked if the underlying function is otherwised called.
            If it is True, we will not save this value as memoized (so next call with hit the function again).
            If it is False, we will save the value to the cache as per normal.
        &#34;&#34;&#34;
        if callable(expire):
            # we&#39;ve been called like:
            # @memoize
            # without () at the end
            func = expire
            expire = None
        else:
            func = None

        def inner(func):
            # Warning: we&#39;re truncating to fit the tag
            tag = f&#34;memoize.{func.__module__}_{func.__qualname__}_{expire!s}&#34;[
                :TAG_MAX_LENGTH
            ]

            def wrapper(*args, **kwargs):
                # Warning: we&#39;re truncating to fit the key
                key = f&#34;{args!s}_{kwargs!s}&#34;[:KEY_MAX_LENGTH]

                # if you overwrite inner.expire_if then the callable would only get evaluated once
                # ... so don&#39;t do that.
                expire_if = inner.expire_if

                if callable(expire_if):
                    expire_if = expire_if()

                try_cache = not bool(expire_if)

                NO_RESULT = object()
                result = NO_RESULT
                if try_cache:
                    try:
                        result = self.get(key, tag=tag)
                    except KeyError:
                        pass
                else:
                    log.debug(f&#34;expire_if is forcing us to ignore cache: {key}&#34;)

                if result == NO_RESULT:
                    result = func(*args, **kwargs)

                    skip_saving_to_cache = False
                    if callable(skip_saving_to_cache_if):
                        if skip_saving_to_cache_if(result):
                            skip_saving_to_cache = True
                    elif skip_saving_to_cache_if:
                        skip_saving_to_cache = skip_saving_to_cache_if

                    if skip_saving_to_cache:
                        log.debug(
                            f&#34;skip_saving_to_cache_if is forcing us to not save to cache the value for key: {key}&#34;
                        )
                    else:
                        self.set(key, result, tag=tag, expire=expire)

                return result

            wrapper.cache_clear = lambda: self.delete_tag(tag)
            return wrapper

        inner.expire_if = expire_if

        if func:
            return inner(func)
        else:
            return inner</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="kvalchemy.client.KVAlchemy.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Clears all key-value pairs from the store.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;
    Clears all key-value pairs from the store.
    &#34;&#34;&#34;
    with self.session() as session:
        session.query(KVStore).delete()</code></pre>
</details>
</dd>
<dt id="kvalchemy.client.KVAlchemy.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, key: str, tag: str = '') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the given key/tag combo from the store.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, key: str, tag: str = &#34;&#34;) -&gt; None:
    &#34;&#34;&#34;
    Deletes the given key/tag combo from the store.
    &#34;&#34;&#34;
    with self.session() as session:
        query = (
            session.query(KVStore)
            .filter(KVStore.non_expired_filter())
            .filter_by(key=key, tag=tag)
        )
        result = query.one_or_none()

        if result is not None:
            session.delete(result)</code></pre>
</details>
</dd>
<dt id="kvalchemy.client.KVAlchemy.delete_tag"><code class="name flex">
<span>def <span class="ident">delete_tag</span></span>(<span>self, tag: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes all keys under a given tag.</p>
<p>Returns the number of keys deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_tag(self, tag: str) -&gt; int:
    &#34;&#34;&#34;
    Deletes all keys under a given tag.

    Returns the number of keys deleted.
    &#34;&#34;&#34;
    with self.session() as session:
        return session.query(KVStore).filter(KVStore.tag == tag).delete()</code></pre>
</details>
</dd>
<dt id="kvalchemy.client.KVAlchemy.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, key: str, default: Any = &lt;object object&gt;, tag: str = '', return_expiration: bool = False) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the value for the given key and tag.</p>
<p>If the key/tag combo is not found (or expired), and a default is provided, the
default value is returned. If no default is provided, a KeyError is raised.</p>
<p>If return_expiration is True, will return the (value, (expiration datetime or None)) as a tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(
    self,
    key: str,
    default: Any = ENOVAL,
    tag: str = &#34;&#34;,
    return_expiration: bool = False,
) -&gt; Any:
    &#34;&#34;&#34;
    Retrieves the value for the given key and tag.

    If the key/tag combo is not found (or expired), and a default is provided, the
    default value is returned. If no default is provided, a KeyError is raised.

    If return_expiration is True, will return the (value, (expiration datetime or None)) as a tuple
    &#34;&#34;&#34;
    with self.session() as session:
        query = (
            session.query(KVStore)
            .filter(KVStore.non_expired_filter())
            .filter_by(key=key, tag=tag)
        )
        result = query.one_or_none()

        if result is None:
            result = ValueMixIn(default)

        if result.value is ENOVAL:
            raise KeyError(f&#34;key: {key}, tag: {tag}&#34;)

        if return_expiration:
            return result.value, getattr(result, &#34;expire&#34;, None)

        return result.value</code></pre>
</details>
</dd>
<dt id="kvalchemy.client.KVAlchemy.get_proxy"><code class="name flex">
<span>def <span class="ident">get_proxy</span></span>(<span>self, key: str, default: Any = &lt;object object&gt;, tag: str = '') ‑> <a title="kvalchemy.proxy.Proxy" href="proxy.html#kvalchemy.proxy.Proxy">Proxy</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a Proxy object for the given key, tag, default.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_proxy(self, key: str, default: Any = ENOVAL, tag: str = &#34;&#34;) -&gt; Proxy:
    &#34;&#34;&#34;
    Returns a Proxy object for the given key, tag, default.
    &#34;&#34;&#34;
    return Proxy(self, key, default, tag)</code></pre>
</details>
</dd>
<dt id="kvalchemy.client.KVAlchemy.memoize"><code class="name flex">
<span>def <span class="ident">memoize</span></span>(<span>self, expire: Union[ForwardRef(None), int, float, datetime.timedelta, datetime.datetime] = None, expire_if: Union[bool, Callable] = False, skip_saving_to_cache_if: Union[bool, Callable] = False)</span>
</code></dt>
<dd>
<div class="desc"><p>A decorator to memoize the results of a function into the key-value store.</p>
<p>expire allows us to specify a ttl to expire this memoization on.</p>
<p>expire_if allows a bool or callable, if callable it will be called (and should return a bool).
If it is True, we'll expire the cache and allow the func to be called.
If it is False, the cache will be hit per the existing ttl.</p>
<p>skip_saving_to_cache_if allows a bool or callable, if callable it will be called with a single param of the value about to be returned
(and should return a bool). This is only checked if the underlying function is otherwised called.
If it is True, we will not save this value as memoized (so next call with hit the function again).
If it is False, we will save the value to the cache as per normal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memoize(
    self,
    expire: ExpirationType = None,
    expire_if: Union[bool, Callable] = False,
    skip_saving_to_cache_if: Union[bool, Callable] = False,
):
    &#34;&#34;&#34;
    A decorator to memoize the results of a function into the key-value store.

    expire allows us to specify a ttl to expire this memoization on.

    expire_if allows a bool or callable, if callable it will be called (and should return a bool).
        If it is True, we&#39;ll expire the cache and allow the func to be called.
        If it is False, the cache will be hit per the existing ttl.

    skip_saving_to_cache_if allows a bool or callable, if callable it will be called with a single param of the value about to be returned
        (and should return a bool). This is only checked if the underlying function is otherwised called.
        If it is True, we will not save this value as memoized (so next call with hit the function again).
        If it is False, we will save the value to the cache as per normal.
    &#34;&#34;&#34;
    if callable(expire):
        # we&#39;ve been called like:
        # @memoize
        # without () at the end
        func = expire
        expire = None
    else:
        func = None

    def inner(func):
        # Warning: we&#39;re truncating to fit the tag
        tag = f&#34;memoize.{func.__module__}_{func.__qualname__}_{expire!s}&#34;[
            :TAG_MAX_LENGTH
        ]

        def wrapper(*args, **kwargs):
            # Warning: we&#39;re truncating to fit the key
            key = f&#34;{args!s}_{kwargs!s}&#34;[:KEY_MAX_LENGTH]

            # if you overwrite inner.expire_if then the callable would only get evaluated once
            # ... so don&#39;t do that.
            expire_if = inner.expire_if

            if callable(expire_if):
                expire_if = expire_if()

            try_cache = not bool(expire_if)

            NO_RESULT = object()
            result = NO_RESULT
            if try_cache:
                try:
                    result = self.get(key, tag=tag)
                except KeyError:
                    pass
            else:
                log.debug(f&#34;expire_if is forcing us to ignore cache: {key}&#34;)

            if result == NO_RESULT:
                result = func(*args, **kwargs)

                skip_saving_to_cache = False
                if callable(skip_saving_to_cache_if):
                    if skip_saving_to_cache_if(result):
                        skip_saving_to_cache = True
                elif skip_saving_to_cache_if:
                    skip_saving_to_cache = skip_saving_to_cache_if

                if skip_saving_to_cache:
                    log.debug(
                        f&#34;skip_saving_to_cache_if is forcing us to not save to cache the value for key: {key}&#34;
                    )
                else:
                    self.set(key, result, tag=tag, expire=expire)

            return result

        wrapper.cache_clear = lambda: self.delete_tag(tag)
        return wrapper

    inner.expire_if = expire_if

    if func:
        return inner(func)
    else:
        return inner</code></pre>
</details>
</dd>
<dt id="kvalchemy.client.KVAlchemy.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, key: str, default: Any = &lt;object object&gt;, tag: str = '') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Pops the given key/tag combo from the store.</p>
<p>If the key/tag combo is not found (or expired), and a default is provided, the
default value is returned. If no default is provided, a KeyError is raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, key: str, default: Any = ENOVAL, tag: str = &#34;&#34;) -&gt; None:
    &#34;&#34;&#34;
    Pops the given key/tag combo from the store.

    If the key/tag combo is not found (or expired), and a default is provided, the
    default value is returned. If no default is provided, a KeyError is raised.
    &#34;&#34;&#34;
    sentinel = object()
    value = self.get(key, sentinel, tag)

    if value is sentinel:
        if default is ENOVAL:
            raise KeyError(f&#34;key: {key}, tag: {tag}&#34;)
        else:
            value = default

    self.delete(key, tag)

    return value</code></pre>
</details>
</dd>
<dt id="kvalchemy.client.KVAlchemy.session"><code class="name flex">
<span>def <span class="ident">session</span></span>(<span>self, commit: bool = True, delete_expired: bool = True) ‑> Iterable[sqlalchemy.orm.session.Session]</span>
</code></dt>
<dd>
<div class="desc"><p>Contextmanager to obtain a temp session with the underlying database.</p>
<p>If commit is True, the session will be committed after the block.
If delete_expired is True, any expired keys will be deleted before exiting the block.
Note that delete_expired only applies if commit is True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextlib.contextmanager
def session(
    self, commit: bool = True, delete_expired: bool = True
) -&gt; Iterable[Session]:
    &#34;&#34;&#34;
    Contextmanager to obtain a temp session with the underlying database.

    If commit is True, the session will be committed after the block.
    If delete_expired is True, any expired keys will be deleted before exiting the block.
        Note that delete_expired only applies if commit is True.
    &#34;&#34;&#34;
    with self._session() as session:
        yield session

        if commit:
            if delete_expired:
                session.query(KVStore).filter(
                    ~KVStore.non_expired_filter()
                ).delete()

            session.commit()</code></pre>
</details>
</dd>
<dt id="kvalchemy.client.KVAlchemy.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, key: str, value: Any, tag: str = '', expire: Union[ForwardRef(None), int, float, datetime.timedelta, datetime.datetime] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the given key/tag combo to the value provided.</p>
<p>If expire is provided, it must be something that can be processed by
the to_expire function in kvalchemy.time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(
    self, key: str, value: Any, tag: str = &#34;&#34;, expire: ExpirationType = None
) -&gt; None:
    &#34;&#34;&#34;
    Sets the given key/tag combo to the value provided.

    If expire is provided, it must be something that can be processed by
    the to_expire function in kvalchemy.time.
    &#34;&#34;&#34;
    with self.session() as session:
        session.merge(
            KVStore(key=key, value=value, tag=tag, expire=to_expire(expire))
        )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="kvalchemy" href="index.html">kvalchemy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="kvalchemy.client.KVAlchemy" href="#kvalchemy.client.KVAlchemy">KVAlchemy</a></code></h4>
<ul class="two-column">
<li><code><a title="kvalchemy.client.KVAlchemy.clear" href="#kvalchemy.client.KVAlchemy.clear">clear</a></code></li>
<li><code><a title="kvalchemy.client.KVAlchemy.delete" href="#kvalchemy.client.KVAlchemy.delete">delete</a></code></li>
<li><code><a title="kvalchemy.client.KVAlchemy.delete_tag" href="#kvalchemy.client.KVAlchemy.delete_tag">delete_tag</a></code></li>
<li><code><a title="kvalchemy.client.KVAlchemy.get" href="#kvalchemy.client.KVAlchemy.get">get</a></code></li>
<li><code><a title="kvalchemy.client.KVAlchemy.get_proxy" href="#kvalchemy.client.KVAlchemy.get_proxy">get_proxy</a></code></li>
<li><code><a title="kvalchemy.client.KVAlchemy.memoize" href="#kvalchemy.client.KVAlchemy.memoize">memoize</a></code></li>
<li><code><a title="kvalchemy.client.KVAlchemy.pop" href="#kvalchemy.client.KVAlchemy.pop">pop</a></code></li>
<li><code><a title="kvalchemy.client.KVAlchemy.session" href="#kvalchemy.client.KVAlchemy.session">session</a></code></li>
<li><code><a title="kvalchemy.client.KVAlchemy.set" href="#kvalchemy.client.KVAlchemy.set">set</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>